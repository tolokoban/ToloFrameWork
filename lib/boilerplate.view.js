"use strict";

var DIGITS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
var RX_INTEGER = /^[0-9]+$/;
var RX_STD_ATT = /^[A-Za-z]+$/;
var RX_TAG_NAME = /^[A-Z]+$/;
var RX_CLS_NAME = /^[a-z]+\.[a-z0-9.-]+$/;
var RX_IDENTIFIER = /[_$a-z][_$a-z0-9]+/i;

exports.generateCodeFrom = function( def, codeBehind ) {
  var code = {
    _counter: -1,
    id: function(prefix, counter) {
      if( typeof prefix === 'undefined' ) prefix = "";
      if( typeof counter !== 'number' ) {
        this._counter++;
        counter = this._counter;
      }
      while( counter >= DIGITS.length ) {
        var modulo = counter % DIGITS.length;
        prefix += DIGITS.charAt(modulo);
        counter = Math.floor( counter / DIGITS.length );
      }
      prefix += DIGITS.charAt(counter);
      return prefix;
    },

    behind: codeBehind,
    requires: {},
    functions: {},
    elementNames: [],
    vars: {},
    that: false,
    pm: false,
    aliases: {},
    section: {
      comments: [],
      attribs: {
        define: [],
        init: []
      },
      elements: {
        define: [],
        init: []
      },
      events: [],
      links: []
    }
  };

  // Define attributes.
  buildViewAttribs( def, code );
  // Transform `def` to make it look like an HTML tag.
  def[0] = def[1];
  def[1] = def[2];
  delete def[2];
  var rootElementName = buildElement( def, code );
  code.section.elements.define.push("//-----------------------");
  code.section.elements.define.push("// Declare root element.");
  code.section.elements.define.push("Object.defineProperty( this, '$', {value: " + rootElementName
                                    + ".$, writable: false, enumerable: false, configurable: false } );");

  // Generate full code.
  var key, val;
  if( code.pm ) {
    code.requires.PM = "require('tfw.binding.property-manager')";
  }
  var out = codeBehind + "\n\n//===============================\n"
        + "// XJS:View autogenerated code.\n";
  out += "/**\n * " + code.section.comments.join("\n * ") + "\n */\n";
  out += "module.exports = function() {\n";
  if( hasAttribs( code.requires ) ) {
    out += "  //---------------\n";
    out += "  // Dependencies.\n";
    for( key in code.requires ) {
      val = code.requires[key];
      out += "  var " + key + " = " + val + ";\n";
    }
  }
  if( hasAttribs( code.functions ) ) {
    out += "  //------------\n";
    out += "  // Functions.\n";
    for( key in code.functions ) {
      val = code.functions[key];
      out += "  function " + key + val + ";\n";
    }
  }
  if( hasAttribs( code.vars ) ) {
    out += "  //-------------------\n";
    out += "  // Global variables.\n";
    for( key in code.vars ) {
      val = code.vars[key];
      out += "  var " + key + " = " + val + ";\n";
    }
  }
  out += "  var ViewClass = function( args ) {\n";
  out += "    this.$elements = {};\n";
  if( code.that ) out += "    var that = this;\n";
  if( code.pm ) out += "    var pm = PM(this);\n";
  out += generate( code.section.attribs.define, "Create attributes", "    " );
  out += generate( code.section.elements.define, "Create elements", "    " );
  out += generate( code.section.events, "Events", "    " );
  out += generate( code.section.links, "Links", "    " );
  out += generate( code.section.elements.init, "Initialize elements", "    " );
  out += generate( code.section.attribs.init, "Initialize attributes", "    " );
  out += "  };\n";
  out += "  return ViewClass;\n";
  out += "}();\n";
  return out;
};

/**
 * Return the code from an array and an identation.
 * The code is preceded by a comment.
 */
function generate( arr, comment, indent ) {
  if( typeof indent === 'undefined' ) indent = "  ";
  if( arr.length === 0 ) return "";
  var len = comment.length + 3;
  var out = indent + "//";
  while( len --> 0 ) out += "-";
  out += "\n";
  out += indent + "// " + comment + ".\n";
  arr.forEach(function (line) {
    out += indent + line + "\n";
  });
  return out;
}

/**
 * @example
 * view.attribs: {
 *   flat: true
 *   type: {[default, primary, secondary]}
 *   count: {integer}
 * }
 */
function buildViewAttribs( def, code ) {
  var attribs = def["view.attribs"];
  if( typeof attribs !== 'object' ) return;
  var attName, attValue;
  for( attName in attribs ) {
    attValue = attribs[attName];
    if( isSpecial( attValue ) ) buildViewAttribsSpecial( attName, attValue, code );
    else buildViewAttribsInit( attName, attValue, code );
  }
}

/**
 * Attribute with casting.
 * @example
 * type: {[default, primary, secondary]}
 * count: {integer}
 */
function buildViewAttribsSpecial( attName, attValue, code ) {
  var type = attValue[0];
  var init = attValue[1];
  var requireConverter = false;

  if( Array.isArray( type ) ) {
    // Enumerate.
    requireConverter = true;
    code.vars.enumCast = "Converters.get('enum')";
    code.pm = true;
    code.section.attribs.define.push(
      "pm.create(" + JSON.stringify(attName)
        + ", { cast: enumCast(" + JSON.stringify(type) + ") });");
    buildViewAttribsInit( attName, init, code );
  }
  else {
    switch( type ) {
    case 'action':
      code.pm = true;
      code.section.attribs.define.push(
        "pm.createAction(" + JSON.stringify(attName) + ")");
      break;
    case 'boolean':
    case 'integer':
    case 'float':
    case 'string':
      requireConverter = true;
      code.vars[type + 'Cast'] = "Converters.get('" + type + "')";
      code.pm = true;
      code.section.attribs.define.push(
        "pm.create(" + JSON.stringify(attName)
          + ", { cast: " + type + "Cast() });");
      buildViewAttribsInit( attName, init, code );
      break;
    default:
      throw "Unknown type \"" + type + "\" for attribute \"" + attName + "\"!";
    }
  }

  if( requireConverter ) {
    code.requires.Converters = "require('tfw.binding.converters')";
  }
}

/**
 * Initialize attribute with a value. Priority to the value set in the
 * contructor args.
 */
function buildViewAttribsInit( attName, attValue, code ) {
  if( attValue === undefined ) {
    code.section.attribs.init.push("this." + attName + " = args["
                                   + JSON.stringify(attName) + "];");
  } else {
    code.functions["defVal"] = "(args, attName, attValue) "
      + "{ return args[attName] === undefined ? attValue : args[attName]; }";
    code.section.attribs.init.push("this." + attName + " = defVal(args, "
                                   + JSON.stringify(attName) + ", " + JSON.stringify(attValue)
                                   + ");");
  }
}

/**
 *
 */
function buildElement( def, code, varName ) {
  varName = getVarName(def, varName);
  addUnique( code.elementNames, varName );
  try {
    var type = def[0];
    if( RX_TAG_NAME.test( type ) ) buildElementTag( def, code, varName );
    else if ( RX_CLS_NAME.text( type ) ) buildElementCls( def, code, varName );
    else throw "Unknown element name: " + JSON.stringify( type ) + "!\n"
      + JSON.stringify( def );

    // Children.
    var children = def[1];
    if( typeof children === 'undefined' ) return varName;
    if( isSpecial(  children ) ) {
      buildElementSpecialChild( children, code, varName );
      return varName;
    }
    if( !Array.isArray( children ) ) children = [children];
    var toAdd = [];
    children.forEach(function (child, index) {
      if( typeof child === 'string' || typeof child === 'number') {
        toAdd.push( JSON.stringify("" + child) );
      }
      else {
        var childVarName = buildElement( child, code, code.id( varName, index ) );
        toAdd.push( childVarName );
      }
    });
    if( toAdd.length > 0 ) {
      code.requires['$'] = "require('dom')";
      code.section.elements.define.push(
        "$.add( " + varName + ", "
          + toAdd.join(", ") + " );");
    }
  }
  catch( ex ) {
    throw "Error in element \"" + varName + "\":\n" + ex;
  }
  finally {
    // Store the variable for use in code behind.
    code.section.elements.define.push(
      "this.$elements" + keySyntax(varName) + " = " + varName + ";");
  }
  return varName;
}

function buildElementTag( def, code, varName ) {
  var attribs = extractAttribs( def );
  buildElementEvents( attribs.special, code, varName );

  var arr = Object.keys( attribs.standard );
  code.requires["Tag"] = "require('tfw.view').Tag";
  code.section.elements.define.push(
    "var " + varName + " = new Tag('" + def[0] + "'"
      + (arr.length > 0 ? ', ' + JSON.stringify(arr) : '')
      + ");");
  buildElementTagAttribsStandard( attribs.standard, code, varName );
  buildElementTagClassSwitcher( attribs.special, code, varName );
}

/**
 * Generate code from attributes starting with "class.".
 * For instance  `class.blue: {Link  focused}` means that  the class
 * `blue`  must be  added if  the  attribute `focused`  is `true`  and
 * removed if `focused` is `false`.
 * On  the contrary,  `class.|red:  {Bind focused}`  means that  the
 * class `red`  must be removed  if `focused`  is `true` and  added if
 * `focused` is `false`.
 * Finally,  `class.blue|red: {Bind  focused}`  is the  mix of  both
 * previous syntaxes.
 */
function buildElementTagClassSwitcher( def, code, varName ) {
  var attName, attValue, classes, classesNames, className;
  for( attName in def ) {
    classesNames = getSuffix( attName, "class." );
    if( !classesNames ) continue;
    attValue = def[attName];
    if( classesNames === '*' ) return buildElementTagClassSwitcherStar( attValue, code, varName );
    if( !attValue || attValue[0] !== 'Bind' ) {
      throw "Only bindings are accepted as values for class-switchers!\n"
        + attName + ": " + JSON.stringify(attValue);
    }
    classes = classesNames.split("|");
    code.section.links.push("pm.on(" + JSON.stringify(attValue[1]) + ", function(v) {");
    if( classes.length > 0 ) {
      code.requires.$ = "require('dom')";
      code.functions["addClassIfTrue"] = "(element, className, value) { "
        + "if( value ) $.addClass(element, className); else $.removeClass(element, className); };";
      className = JSON.stringify(classes[0]);
      code.section.links.push("  addClassIfTrue( " + varName + ", " + className + ", v );");
    }
    if( classes.length > 1 && classes[1].length > 0 ) {
      code.requires.$ = "require('dom')";
      code.functions["addClassIfFalse"] = "(element, className, value) { "
        + "if( value ) $.removeClass(element, className); else $.addClass(element, className); };";
      className = JSON.stringify(classes[1]);
      code.section.links.push("  addClassIfFalse( " + varName + ", " + className + ", v );");
    }
    code.section.links.push("});");
  }
}

function buildElementTagClassSwitcherStar( items, code, varName ) {
  if( !Array.isArray( items ) ) items = [items];
  items.forEach(function (item, index) {
    var funcName = code.id("applyClass");
    var sources = item[0];
    if( typeof sources === 'string' ) sources = [sources];
    if( !Array.isArray( sources ) )
      throw "The first item in a class switcher must be an array of properties to bind on!\n"
      + "You gave: " + JSON.stringify( item );
    var behindFunction = item[1];
    if( typeof behindFunction !== 'string' )
      throw "The second item in a class switcher must be the name of a function from code behind!\n"
      + "You gave: " + JSON.stringify( item );
    code.functions[funcName] =
      "() {\n    this.$elements" + keySyntax(varName)
      + ".applyClass(" + behindFunction + ".call(this), " + index + "); }";
    sources.forEach(function (source) {
      code.section.links.push.apply(code.section.links, generateBind({
        "0": "Bind", "1": source, action: funcName
      }, code));
    });
  });
}

function generateBind( def, code ) {
  try {
    if( def[0] !== 'Bind' ) throw "This is not a binding statement!";
    if( typeof def[2] !== 'undefined' ) {
      def.action = def[2];
      delete def[2];
    }
    var sources = def[1];
    if( typeof sources === 'string' ) sources = [sources];
    if( !Array.isArray( sources ) )
      throw "The second item of a binding statement must be an array of properties to bind on!";

    var result = [];
    sources.forEach(function (source, index) {
      if( typeof source !== 'string' )
        throw "An array of bindable properties must be made of strings (#" + index + ")!";
      var emitter = path2BindPod( source );
      result.push("new Link({");
      result.push(
        "  A:{ obj: " + emitter.obj + ", name: " + JSON.stringify( emitter.name  )
          + ", open: false },");
      var output = "  B:{ open:true";
      var attName, attValue;
      for( attName in def ) {
        if( !RX_IDENTIFIER.test( attName ) ) continue;
        attValue = def[attName];
        if( attName === 'action' ) {
          output += ", action: " + attValue + ".bind(that)";
        }
        else {
          output += ", " + attName + ": " + JSON.stringify( attValue );
        }
      }
      result.push( output + " }" );
      result.push("});");
    });

    code.requires["Link"] = "require('tfw.binding.link');";
    code.that = true;
    return result;
  }
  catch( ex ) {
    throw ex + "\nYou gave: " + JSON.stringify( def );
  }
}

function buildElementEvents( attribs, code, varName ) {
  var attName, attValue;
  for( attName in attribs ) {
    var eventName = getSuffix( attName, "event." );
    if( !eventName ) continue;
    attValue = attribs[attName];
    if( typeof attValue === 'string' ) {
      // Using a function from code behind.
      code.section.events.push(
        "$.on( " + varName + ", " + JSON.stringify( eventName ) + ", "
          + attValue + ".bind( this ) );");
    } else {
      code.section.events.push(
        "$.on( " + varName + ", " + JSON.stringify( eventName ) + ", function(v) {");
      code.section.events.push.apply(
        code.section.events,
        generateFunctionBody(attValue, code, "  "));
      code.section.events.push("});");
    }
  }
}

function buildElementTagAttribsStandard( attribs, code, varName ) {
  var attName, attValue;
  for( attName in attribs ) {
    attValue = attribs[attName];
    if( isSpecial( attValue ) ) {
      // Links!
      // @TODO
    }
    else {
      code.section.elements.init.push(
        varName + keySyntax(attName) + " = " + JSON.stringify( attValue ) + ";");
    }
  }
}


function buildElementCls( def, code, varName ) {
  // @TODO.
}

function buildElementSpecialChild( def, code, varName ) {
  var type = def[0];
  if( type !== 'Bind' )
    throw "For tag elements, the children can be defined by an array or by `{Bind ...}`!\n"
    + "You provided `{" + type + " ...}`.";
  code.pm = true;
  code.section.links.push(
    "pm.on('" + def[1] + "', function(v) { $.clear(" + varName + ", v); });");
}

function generateFunctionBody(def, code, indent) {
  code.that = true;
  var output = [];
  if( !Array.isArray( def ) ) def = [def];
  def.forEach(function (item) {
    if( typeof item === 'string' ) {
      output.push( indent + item + ".call( that );" );
    }
    else if( isSpecial ) {
      var type = item[0].toLowerCase();
      var generator = functionBodyGenerators[type];
      if( typeof generator !== 'function' ) {
        throw "Don't know how to build a function body from " + JSON.stringify( def ) + "!\n"
          + "Known commands are: " + Object.key(functionBodyGenerators).join( ", " ) + ".";
      }
      generator( output, item, code, indent );
    }
  });

  return output;
}

var functionBodyGenerators = {
  toggle: function( output, def, code, indent ) {
    var elemVar = getElementVarFromPath( def[1] ).join( "" );
    output.push(
      indent + elemVar + " = " + elemVar + " ? false : true;");
  },
  set: function( output, def, code, indent ) {
    var elemVar = getElementVarFromPath( def[1] ).join( "" );
    output.push(
      indent + elemVar + " = " + JSON.stringify( def[2] ));
  }
};

/**
 * A path is a string which represent a variable.
 */
function getElementVarFromPath( path, root ) {
  if( typeof root === 'undefined' ) root = "that";
  var items = path.split("/").map( function(item) {
    return camelCase( item.trim() );
  });
  if( items.length === 1 ) items.unshift( root );
  if( items[0] === "" ) items[0] = root;
  var result = items.map(function(x, i) {
    if( i === 0 ) return x;
    if( i === items.length - 1 ) return "." + x;
    return keySyntax( "element" + capitalize( x ) ) ;
  });
  return result;
}

function path2BindPod( path, root ) {
  var items = getElementVarFromPath( path, root );
  var pod = { name: items.pop().substr(1) };
  pod.obj = items.join("");
  return pod;
}

/**
 * An attribute is marked as _special_ as soon as it ha a dot in its name.
 * `view.attribs` is special, but `attribs` is not.
 * Attributes with a numeric key are marked as _implicit_.
 * @return `{ standard: {...}, special: {...}, implicit: [...] }`.
 */
function extractAttribs( def ) {
  var key, val, attribs = { standard: {}, special: {}, implicit: [] };
  for( key in def ) {
    val = def[key];
    if( RX_INTEGER.test( key ) ) {
      attribs.implicit.push( val );
    }
    else if( RX_STD_ATT.test( key ) ) {
      attribs.standard[key] = val;
    }
    else {
      attribs.special[key] = val;
    }
  }
  return attribs;
}

/**
 * Determine if an object is special or not.
 * An object is special as soon as it own the "0" attribute.
 */
function isSpecial( obj ) {
  var type = typeof obj;
  if( type === 'string' || type !== 'object' || Array.isArray(obj) ) return false;
  if( !obj ) return false;
  return typeof obj[0] !== undefined;
}

/**
 * Check if an object has attributes or not.
 * It is empty if it has no attribute.
 */
function isEmptyObj( obj ) {
  for( var k in obj ) return false;
  return true;
}

/**
 * Check if an object as at least on attribute.
 */
function hasAttribs( obj ) {
  for( var k in obj ) return true;
  return false;
}

function CamelCase( name ) {
  return name.split('.').map(function(word) {
    return word.split('-').map(capitalize).join("");
  }).join("");
}

function camelCase( name ) {
  var cm = CamelCase( name );
  return cm.charAt(0).toLowerCase() + cm.substr(1);
}

function capitalize( name ) {
  return name.charAt(0).toUpperCase() + name.substr(1).toLowerCase();
}

function getSuffix( text, prefix ) {
  if( text.substr( 0, prefix.length ) !== prefix ) return null;
  return text.substr( prefix.length );
}

function getVarName( def, defaultVarName ) {
  var id = def["view.id"];
  if( typeof id === 'undefined' ) {
    if( typeof defaultVarName === 'undefined' ) return "elem";
    return defaultVarName;
  }
  return "element" + CamelCase(id);
}

function addUnique(arr, item) {
  if( arr.indexOf( item ) === -1 ) {
    arr.push( item );
  }
}

function keySyntax( name ) {
  if( RX_IDENTIFIER.test( name ) ) return "." + name;
  return "[" + JSON.stringify( name ) + "]";
}
